<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Making a Calculator in Haskell with Parsec | fpunfold</title>
<meta name="generator" content="Jekyll v3.9.0" />
<meta property="og:title" content="Making a Calculator in Haskell with Parsec" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="My adventures with code." />
<meta property="og:description" content="My adventures with code." />
<link rel="canonical" href="http://localhost:4000/haskell/functional-programming/2020/05/18/making-a-calculator-in-haskell-with-parsec.html" />
<meta property="og:url" content="http://localhost:4000/haskell/functional-programming/2020/05/18/making-a-calculator-in-haskell-with-parsec.html" />
<meta property="og:site_name" content="fpunfold" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-05-18T19:30:17-04:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Making a Calculator in Haskell with Parsec" />
<script type="application/ld+json">
{"url":"http://localhost:4000/haskell/functional-programming/2020/05/18/making-a-calculator-in-haskell-with-parsec.html","headline":"Making a Calculator in Haskell with Parsec","dateModified":"2020-05-18T19:30:17-04:00","datePublished":"2020-05-18T19:30:17-04:00","description":"My adventures with code.","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/haskell/functional-programming/2020/05/18/making-a-calculator-in-haskell-with-parsec.html"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="fpunfold" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">fpunfold</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Making a Calculator in Haskell with Parsec</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2020-05-18T19:30:17-04:00" itemprop="datePublished">May 18, 2020
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p><img src="https://fpunfold.com/wp-content/uploads/2020/05/calculator.001.jpeg" alt="Calculator" /></p>

<p>In this article, I will show you how to use <a href="https://wiki.haskell.org/Parsec">Parsec</a> in an Applicative style to parse and evaluate simple expressions. We will make a Calculator in Haskell with Parsec library. Our calculator will support addition, subtraction, multiplication, division, and parentheses with their respective precedences. This article is aimed at showing the power of Parsec and Parsec-like libraries and the elegance of Applicative programming. Read our introductory piece on <a href="https://fpunfold.com/2020/05/12/applicative-functor-for-beginners/">Applicatives</a> for more information on Applicative Functors.</p>

<h2 id="imports">Imports</h2>
<p>We’ll use the following imports for our program.</p>
<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- calculator.hs</span>
<span class="kr">import</span> <span class="nn">Text.Parsec</span> <span class="p">(</span><span class="nf">char</span><span class="p">,</span> <span class="nf">between</span><span class="p">,</span> <span class="nf">digit</span><span class="p">,</span> <span class="nf">many1</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Text.Parsec.String</span> <span class="p">(</span><span class="kt">Parser</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Data.Char</span> <span class="p">(</span><span class="nf">digitToInt</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Control.Applicative</span> <span class="p">(</span><span class="nf">optional</span><span class="p">,</span> <span class="p">(</span><span class="o">&lt;|&gt;</span><span class="p">),</span> <span class="nf">many</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="parsing-decimals">Parsing decimals</h2>
<p>Parsec does not come with decimal parser out of the box so first let’s define a decimal parser. We simply parse one or more digits and then convert the parsed string to the integer it represents.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- calculator.hs</span>
<span class="n">decimal</span> <span class="o">::</span> <span class="kt">Parsec</span> <span class="kt">String</span> <span class="nb">()</span> <span class="kt">Int</span> 
<span class="n">decimal</span> <span class="o">=</span> <span class="n">atoi</span> <span class="o">&lt;$&gt;</span> <span class="n">many1</span> <span class="n">digit</span>

<span class="n">atoi</span> <span class="o">::</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="kt">Int</span> 
<span class="n">atoi</span> <span class="o">=</span> <span class="n">foldl</span> <span class="n">f</span> <span class="mi">0</span> <span class="kr">where</span> 
    <span class="n">f</span> <span class="n">s</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">10</span><span class="o">*</span><span class="n">s</span> <span class="o">+</span> <span class="n">digitToInt</span> <span class="n">x</span>
</code></pre></div></div>

<p>We use the <code class="language-plaintext highlighter-rouge">many1</code> function from <code class="language-plaintext highlighter-rouge">Text.Parsec</code> that parses one or more occurrences of whatever pattern you give it. Here we are using it to parse one or more digits. Next, we map the parsed digits in string format to an integer using <code class="language-plaintext highlighter-rouge">atoi</code> function. <code class="language-plaintext highlighter-rouge">atoi</code> function folds the digits to produce the integer they represent. For each new digit we shift the current integer to left (multiply by 10) and add the new digit to it.</p>

<h2 id="calculator-grammar">Calculator Grammar</h2>
<p>We’ll use the popular calculator grammar to define our parsing rules later. The snippet below shows the grammar in <a href="https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form">Backus-Naur form (BNF)</a>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Expr   ::= Term ('+' Term | '-' Term)*
Term   ::= Factor ('*' Factor | '/' Factor)*
Factor ::= ['-'] (Number | '(' Expr ')')
Number ::= Digit+
</code></pre></div></div>

<p>According to our grammar above, an expression <code class="language-plaintext highlighter-rouge">Expr</code> is either a single term <code class="language-plaintext highlighter-rouge">Term</code> or multiple terms joined with <code class="language-plaintext highlighter-rouge">+</code> or <code class="language-plaintext highlighter-rouge">-</code> operators. Addition and Subtraction are handled at <code class="language-plaintext highlighter-rouge">Expr</code> level. A <code class="language-plaintext highlighter-rouge">Term</code> is either a single <code class="language-plaintext highlighter-rouge">Factor</code> or multiple <code class="language-plaintext highlighter-rouge">Factor</code>s joined with <code class="language-plaintext highlighter-rouge">*</code> or <code class="language-plaintext highlighter-rouge">/</code> operators. Multiplication and division are handled at <code class="language-plaintext highlighter-rouge">Term</code> level. A <code class="language-plaintext highlighter-rouge">Factor</code> is either a number or an expression inside a parentheses. <code class="language-plaintext highlighter-rouge">Factor</code> can optionally be prefixed with <code class="language-plaintext highlighter-rouge">-</code> sign to make it negative. Parentheses are handled at <code class="language-plaintext highlighter-rouge">Factor</code> level. <code class="language-plaintext highlighter-rouge">Number</code> is defined as one or more digits representing an integer.</p>

<h2 id="implementing-the-grammar-in-parsec">Implementing the grammar in Parsec</h2>
<p>Now it’s time to write some Haskell to implement the above grammar using Parsec.</p>

<h3 id="expr">Expr</h3>
<p>```haskell– calculator.hs
expr :: Parser Int
expr = pure eval &lt;<em>&gt; term &lt;</em>&gt; many (pure (,) &lt;<em>&gt; (char ‘+’ &lt;|&gt; char ‘-‘) &lt;</em>&gt; term)</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
First is the `expr :: Parser Int` Parser that corresponds to `Expr` symbol in our grammar. Type `Parser` is imported from `Text.Parsec.String` module and represents a parser of `String` type. So `Parser Int` is a parser of `String` that produces an `Int`.

Now consider `term &lt;*&gt; many (pure (,) &lt;*&gt; (char '+' &lt;|&gt; char '-') &lt;*&gt; term)` part of our parser definition. Here we parse a `term` (we'll define it later) that's followed by zero or more (`many`) `(char '+' &lt;|&gt; char '-') &lt;*&gt; term` parts. This is exactly how we defined `Expr` symbol in our grammar. We use the choice function `&lt;|&gt;` function from `Control.Applicative` to tell Parsec to parse either a `+` or a `-` character (but not both). We use the `&lt;*&gt;` function from `Control.Applicative` to lift a pure function `(,)` to apply it to the character produced by `(char '+' &lt;|&gt; char '-')` and the `term` produced the following `term` parser to wrap them in a tuple. The type of `term` as we'll see later is `Parser Int` so `pure (,) &lt;*&gt; (char '+' &lt;|&gt; char '-') &lt;*&gt; term` gives us a parser of type `Parser (Char, Int)`. `many` function from Applicative module is applied here to tell Parsec to keep parsing `(Char, Int)` as long as it can. Thus, applying `many` to `Parser (Char, Int)` type gives us a parser of type `Parser [(Char, Int)]`.

Next, we need to combine the `Parser Int` from our first `term` and `Parser [(Char, Int)]` into a single `Parser Int`. We do that by applying a pure function `eval :: Int -&gt; [(Char,Int)] -&gt; Int` (we'll define this later) that will fold the parsed integers and operators into a single integer by adding/subtracting the integers as appropriate. Once again we use `&lt;*&gt;` function to apply `eval` on values wrapped in Applicatives (`Parser`s).

### Term
```haskell
-- calculator.hs
term :: Parser Int 
term = pure eval &lt;*&gt; factor &lt;*&gt; many (pure (,) &lt;*&gt; (char '*' &lt;|&gt; char '/') &lt;*&gt; factor)
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">term</code> parser is very similar to <code class="language-plaintext highlighter-rouge">expr</code> just like the <code class="language-plaintext highlighter-rouge">Term</code> symbol is similar to <code class="language-plaintext highlighter-rouge">Expr</code> symbol in our grammar. Here instead of parsing <code class="language-plaintext highlighter-rouge">+</code> and <code class="language-plaintext highlighter-rouge">-</code> operators we parse <code class="language-plaintext highlighter-rouge">*</code> and <code class="language-plaintext highlighter-rouge">/</code> instead. Instead of parsing <code class="language-plaintext highlighter-rouge">term</code>s we parse <code class="language-plaintext highlighter-rouge">factor</code>s as described in our grammar.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- calculator.hs</span>
<span class="n">eval</span> <span class="o">::</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="p">[(</span><span class="kt">Char</span><span class="p">,</span><span class="kt">Int</span><span class="p">)]</span> <span class="o">-&gt;</span> <span class="kt">Int</span> 
<span class="n">eval</span> <span class="n">x</span> <span class="kt">[]</span> <span class="o">=</span> <span class="n">x</span> 
<span class="n">eval</span> <span class="n">x</span> <span class="p">((</span><span class="sc">'+'</span><span class="p">,</span> <span class="n">x'</span><span class="p">)</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="o">=</span> <span class="n">eval</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">x'</span><span class="p">)</span> <span class="n">xs</span>
<span class="n">eval</span> <span class="n">x</span> <span class="p">((</span><span class="sc">'-'</span><span class="p">,</span> <span class="n">x'</span><span class="p">)</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="o">=</span> <span class="n">eval</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">x'</span><span class="p">)</span> <span class="n">xs</span>
<span class="n">eval</span> <span class="n">x</span> <span class="p">((</span><span class="sc">'*'</span><span class="p">,</span> <span class="n">x'</span><span class="p">)</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="o">=</span> <span class="n">eval</span> <span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">x'</span><span class="p">)</span> <span class="n">xs</span>
<span class="n">eval</span> <span class="n">x</span> <span class="p">((</span><span class="sc">'/'</span><span class="p">,</span> <span class="n">x'</span><span class="p">)</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="o">=</span> <span class="n">eval</span> <span class="p">(</span><span class="n">x</span> <span class="p">`</span><span class="n">div</span><span class="p">`</span> <span class="n">x'</span><span class="p">)</span> <span class="n">xs</span>
</code></pre></div></div>

<p>Now we define <code class="language-plaintext highlighter-rouge">eval</code> function as shown above. It is a simple folding function that has an aggregator to which it adds/subtracts/multiplies/divides integers from the list depending on what operator they carry with them.</p>

<h3 id="factor">Factor</h3>
<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- calculator.hs</span>
<span class="n">factor</span> <span class="o">::</span> <span class="kt">Parser</span> <span class="kt">Int</span> 
<span class="n">factor</span> <span class="o">=</span> <span class="n">pure</span> <span class="n">f</span> <span class="o">&lt;*&gt;</span> <span class="n">optional</span> <span class="p">(</span><span class="n">char</span> <span class="sc">'-'</span><span class="p">)</span> <span class="o">&lt;*&gt;</span> <span class="p">(</span><span class="n">decimal</span> <span class="o">&lt;|&gt;</span> <span class="n">between</span> <span class="p">(</span><span class="n">char</span> <span class="sc">'('</span><span class="p">)</span> <span class="p">(</span><span class="n">char</span> <span class="sc">')'</span><span class="p">)</span> <span class="n">expr</span><span class="p">)</span>
    <span class="kr">where</span> 
        <span class="n">f</span> <span class="kt">Nothing</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> 
        <span class="n">f</span> <span class="kr">_</span> <span class="n">x</span> <span class="o">=</span> <span class="n">negate</span> <span class="n">x</span>
</code></pre></div></div>

<p>Our final piece is the <code class="language-plaintext highlighter-rouge">factor</code> parser. With <code class="language-plaintext highlighter-rouge">(decimal &lt;|&gt; between (char '(') (char ')') expr)</code> it parses either a <code class="language-plaintext highlighter-rouge">decimal</code> or an <code class="language-plaintext highlighter-rouge">expr</code> wrapped in parentheses. It also parses an optional <code class="language-plaintext highlighter-rouge">-</code> character before the decimal or expression using the <code class="language-plaintext highlighter-rouge">optional</code> function from <code class="language-plaintext highlighter-rouge">Control.Applicative</code> module. This is for negation of the decimal or the expression, of course. Finally, we produce a value by applying <code class="language-plaintext highlighter-rouge">f</code> function on the optional negation operator and the parsed integer value. <code class="language-plaintext highlighter-rouge">f</code> simply negates the parsed integer value if the <code class="language-plaintext highlighter-rouge">-</code> operator was parsed by the parser.</p>

<h2 id="showtime">Showtime</h2>
<p>And that’s it! Let’s give our tiny calculator a go.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- ghci</span>
<span class="err">λ</span><span class="o">&gt;</span> <span class="o">:</span><span class="n">l</span> <span class="n">calculator</span><span class="o">.</span><span class="n">hs</span> 
<span class="p">[</span><span class="mi">1</span> <span class="kr">of</span> <span class="mi">1</span><span class="p">]</span> <span class="kt">Compiling</span> <span class="kt">Main</span>             <span class="p">(</span> <span class="n">calculator</span><span class="o">.</span><span class="n">hs</span><span class="p">,</span> <span class="n">interpreted</span> <span class="p">)</span>
<span class="kt">Ok</span><span class="p">,</span> <span class="n">one</span> <span class="kr">module</span> <span class="err">loaded.</span>
<span class="err">λ&gt;</span> <span class="err">import</span> <span class="nn">Text.Parsec</span> <span class="p">(</span><span class="nf">parse</span><span class="p">)</span>
<span class="err">λ&gt;</span> <span class="err">parse</span> <span class="err">expr</span> <span class="err">""</span> <span class="err">"1+1"</span>
<span class="nn">Right</span> <span class="mi">2</span>
<span class="err">λ</span><span class="o">&gt;</span> <span class="n">parse</span> <span class="n">expr</span> <span class="s">""</span> <span class="s">"1+1-2"</span>
<span class="kt">Right</span> <span class="mi">0</span>
<span class="err">λ</span><span class="o">&gt;</span> <span class="n">parse</span> <span class="n">expr</span> <span class="s">""</span> <span class="s">"1+2*3*2-2"</span>
<span class="kt">Right</span> <span class="mi">11</span>
<span class="err">λ</span><span class="o">&gt;</span> <span class="n">parse</span> <span class="n">expr</span> <span class="s">""</span> <span class="s">"1+2*3*(2-2)"</span>
<span class="kt">Right</span> <span class="mi">1</span>
</code></pre></div></div>

<p>Looks like it works! You can try adding support for more operators such as exponentiation, log, square root etc.</p>

<h2 id="summary">Summary</h2>
<p>Today we saw some Applicative coding in action for making a Calculator app in Haskell with Parsec. You might have noticed that we used no <code class="language-plaintext highlighter-rouge">let</code> declarations or <code class="language-plaintext highlighter-rouge">do</code> notations anywhere in our code. This is a typical benefit of Applicative style of coding. <code class="language-plaintext highlighter-rouge">&lt;*&gt;</code> is a powerful function that allows us to write compact and succinct code that has a great functional feel. Happy Haskelling!</p>

<h2 id="appendix---source-code">Appendix - Source code</h2>
<p>The complete calculator program is reproduced below.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- calculator.hs</span>
<span class="kr">import</span> <span class="nn">Text.Parsec</span> <span class="p">(</span><span class="nf">char</span><span class="p">,</span> <span class="nf">between</span><span class="p">,</span> <span class="nf">digit</span><span class="p">,</span> <span class="nf">many1</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Text.Parsec.String</span> <span class="p">(</span><span class="kt">Parser</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Data.Char</span> <span class="p">(</span><span class="nf">digitToInt</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Control.Applicative</span> <span class="p">(</span><span class="nf">optional</span><span class="p">,</span> <span class="p">(</span><span class="o">&lt;|&gt;</span><span class="p">),</span> <span class="nf">many</span><span class="p">)</span>

<span class="n">atoi</span> <span class="o">::</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="kt">Int</span> 
<span class="n">atoi</span> <span class="o">=</span> <span class="n">foldl</span> <span class="n">f</span> <span class="mi">0</span> <span class="kr">where</span> 
    <span class="n">f</span> <span class="n">s</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">10</span><span class="o">*</span><span class="n">s</span> <span class="o">+</span> <span class="n">digitToInt</span> <span class="n">x</span>

<span class="n">decimal</span> <span class="o">::</span> <span class="kt">Parser</span> <span class="kt">Int</span> 
<span class="n">decimal</span> <span class="o">=</span> <span class="n">atoi</span> <span class="o">&lt;$&gt;</span> <span class="n">many1</span> <span class="n">digit</span>

<span class="n">expr</span> <span class="o">::</span> <span class="kt">Parser</span> <span class="kt">Int</span>
<span class="n">expr</span> <span class="o">=</span> <span class="n">pure</span> <span class="n">eval</span> <span class="o">&lt;*&gt;</span> <span class="n">term</span> <span class="o">&lt;*&gt;</span> <span class="n">many</span> <span class="p">(</span><span class="n">pure</span> <span class="p">(,)</span> <span class="o">&lt;*&gt;</span> <span class="p">(</span><span class="n">char</span> <span class="sc">'+'</span> <span class="o">&lt;|&gt;</span> <span class="n">char</span> <span class="sc">'-'</span><span class="p">)</span> <span class="o">&lt;*&gt;</span> <span class="n">term</span><span class="p">)</span>

<span class="n">term</span> <span class="o">::</span> <span class="kt">Parser</span> <span class="kt">Int</span> 
<span class="n">term</span> <span class="o">=</span> <span class="n">pure</span> <span class="n">eval</span> <span class="o">&lt;*&gt;</span> <span class="n">factor</span> <span class="o">&lt;*&gt;</span> <span class="n">many</span> <span class="p">(</span><span class="n">pure</span> <span class="p">(,)</span> <span class="o">&lt;*&gt;</span> <span class="p">(</span><span class="n">char</span> <span class="sc">'*'</span> <span class="o">&lt;|&gt;</span> <span class="n">char</span> <span class="sc">'/'</span><span class="p">)</span> <span class="o">&lt;*&gt;</span> <span class="n">factor</span><span class="p">)</span>

<span class="n">eval</span> <span class="o">::</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="p">[(</span><span class="kt">Char</span><span class="p">,</span><span class="kt">Int</span><span class="p">)]</span> <span class="o">-&gt;</span> <span class="kt">Int</span> 
<span class="n">eval</span> <span class="n">x</span> <span class="kt">[]</span> <span class="o">=</span> <span class="n">x</span> 
<span class="n">eval</span> <span class="n">x</span> <span class="p">((</span><span class="sc">'+'</span><span class="p">,</span> <span class="n">x'</span><span class="p">)</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="o">=</span> <span class="n">eval</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">x'</span><span class="p">)</span> <span class="n">xs</span>
<span class="n">eval</span> <span class="n">x</span> <span class="p">((</span><span class="sc">'-'</span><span class="p">,</span> <span class="n">x'</span><span class="p">)</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="o">=</span> <span class="n">eval</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">x'</span><span class="p">)</span> <span class="n">xs</span>
<span class="n">eval</span> <span class="n">x</span> <span class="p">((</span><span class="sc">'*'</span><span class="p">,</span> <span class="n">x'</span><span class="p">)</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="o">=</span> <span class="n">eval</span> <span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">x'</span><span class="p">)</span> <span class="n">xs</span>
<span class="n">eval</span> <span class="n">x</span> <span class="p">((</span><span class="sc">'/'</span><span class="p">,</span> <span class="n">x'</span><span class="p">)</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="o">=</span> <span class="n">eval</span> <span class="p">(</span><span class="n">x</span> <span class="p">`</span><span class="n">div</span><span class="p">`</span> <span class="n">x'</span><span class="p">)</span> <span class="n">xs</span>

<span class="n">factor</span> <span class="o">::</span> <span class="kt">Parser</span> <span class="kt">Int</span> 
<span class="n">factor</span> <span class="o">=</span> <span class="n">pure</span> <span class="n">f</span> <span class="o">&lt;*&gt;</span> <span class="n">optional</span> <span class="p">(</span><span class="n">char</span> <span class="sc">'-'</span><span class="p">)</span> <span class="o">&lt;*&gt;</span> <span class="p">(</span><span class="n">decimal</span> <span class="o">&lt;|&gt;</span> <span class="n">between</span> <span class="p">(</span><span class="n">char</span> <span class="sc">'('</span><span class="p">)</span> <span class="p">(</span><span class="n">char</span> <span class="sc">')'</span><span class="p">)</span> <span class="n">expr</span><span class="p">)</span>
    <span class="kr">where</span> 
        <span class="n">f</span> <span class="kt">Nothing</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> 
        <span class="n">f</span> <span class="kr">_</span> <span class="n">x</span> <span class="o">=</span> <span class="n">negate</span> <span class="n">x</span>
</code></pre></div></div>

  </div><a class="u-url" href="/haskell/functional-programming/2020/05/18/making-a-calculator-in-haskell-with-parsec.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">fpunfold</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">fpunfold</li><li><a class="u-email" href="mailto:amoghdroid09@gmail.com">amoghdroid09@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/amogh09"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">amogh09</span></a></li><li><a href="https://www.twitter.com/RathoreAmogh"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">RathoreAmogh</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>My adventures with code.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
