<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Applicative Functor for beginners | fpunfold</title>
<meta name="generator" content="Jekyll v3.9.0" />
<meta property="og:title" content="Applicative Functor for beginners" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="This article presumes beginner level knowledge of Haskell programming language on part of the reader. To get the most out of this article some knowledge of basic Haskell syntax, basic data types like Maybe and Either, and Functor typeclass will be highly beneficial." />
<meta property="og:description" content="This article presumes beginner level knowledge of Haskell programming language on part of the reader. To get the most out of this article some knowledge of basic Haskell syntax, basic data types like Maybe and Either, and Functor typeclass will be highly beneficial." />
<link rel="canonical" href="http://localhost:4000/haskell/functional-programming/2020/05/12/applicative-functor-for-beginners.html" />
<meta property="og:url" content="http://localhost:4000/haskell/functional-programming/2020/05/12/applicative-functor-for-beginners.html" />
<meta property="og:site_name" content="fpunfold" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-05-12T19:30:17-04:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Applicative Functor for beginners" />
<script type="application/ld+json">
{"url":"http://localhost:4000/haskell/functional-programming/2020/05/12/applicative-functor-for-beginners.html","headline":"Applicative Functor for beginners","dateModified":"2020-05-12T19:30:17-04:00","datePublished":"2020-05-12T19:30:17-04:00","description":"This article presumes beginner level knowledge of Haskell programming language on part of the reader. To get the most out of this article some knowledge of basic Haskell syntax, basic data types like Maybe and Either, and Functor typeclass will be highly beneficial.","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/haskell/functional-programming/2020/05/12/applicative-functor-for-beginners.html"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="fpunfold" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">fpunfold</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Applicative Functor for beginners</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2020-05-12T19:30:17-04:00" itemprop="datePublished">May 12, 2020
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p><em>This article presumes beginner level knowledge of Haskell programming language on part of the reader. To get the most out of this article some knowledge of basic Haskell syntax, basic data types like Maybe and Either, and Functor typeclass will be highly beneficial.</em></p>

<p><img src="https://fpunfold.com/wp-content/uploads/2020/05/haskell_unfold.001-300x176.jpeg" alt="unfold" /></p>

<h2 id="what-this-post-covers">What this post covers?</h2>
<p>After reading this post you’ll have a basic understanding of Applicative Functors. You’ll also see some relatable real-life problems where Applicative Functors can come in handy and yield an elegant solution.</p>

<h2 id="applicative-functor">Applicative Functor</h2>
<p>In an earlier article I explained about <a href="https://fpunfold.com/2020/05/08/functor/">Functors</a>. A quick refresher is that a Functor is a container or a context whose value(s) could be mapped over with a function to produce a new Functor. This is done using the <code class="language-plaintext highlighter-rouge">fmap</code> function. Haskell defines the following typeclass for Functors.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">class</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="kr">where</span>
    <span class="n">fmap</span> <span class="o">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
</code></pre></div></div>

<p>Applicative Functor is a Functor that has a few more tricks up its sleeve. List, Maybe, Either all are Applicative Functors as we’ll discover later. First let’s see the extra functions that it supports.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">class</span> <span class="p">(</span><span class="kt">Functor</span> <span class="n">f</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kt">Applicative</span> <span class="n">f</span> <span class="kr">where</span> 
    <span class="n">pure</span>  <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span> 
    <span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span> <span class="o">::</span> <span class="n">f</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">(Functor f) =&gt;</code> just means that any Applicative must also be a Functor; it is a constraint. The first function we have is <code class="language-plaintext highlighter-rouge">pure :: a -&gt; f a</code>. This is a simple function that takes any value and returns an Applicative Functor that wraps the value. You can think of it as providing a <emp>pure</emp> (simple or trivial) context for the value. For lists, this function returns a list with a single element (a singleton list). For <code class="language-plaintext highlighter-rouge">Maybe</code>, it wraps the value in a <code class="language-plaintext highlighter-rouge">Just</code>. And for an <code class="language-plaintext highlighter-rouge">Either</code> it wraps the value in a <code class="language-plaintext highlighter-rouge">Right</code>. I hope there are no surprises here.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-- ghci (Haskell shell)
λ&gt; pure "fpunfold" :: Maybe String
Just "fpunfold"
λ&gt; pure "fpunfold" :: [String]
["fpunfold"]
λ&gt; pure "fpunfold" :: Either String String
Right "fpunfold"
</code></pre></div></div>

<p>The second function Applicative Functor supports is <code class="language-plaintext highlighter-rouge">(&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b</code>. As the type signature suggests, <code class="language-plaintext highlighter-rouge">&lt;*&gt;</code> takes an Applicative (short for Applicative Functor) that contains a function of type <code class="language-plaintext highlighter-rouge">a -&gt; b</code> and applies it to a value inside another Applicative <code class="language-plaintext highlighter-rouge">f a</code>, while merging the contexts of the two Applicatives. Hmm.. who in their right mind would wrap a function inside a container like Applicative?. This might look funky at first but trust me it’ll make much more sense later when you see it in action with some examples. But before that let’s see how <code class="language-plaintext highlighter-rouge">Maybe</code> is an Applicative.</p>

<h2 id="maybe-type-as-an-applicative">Maybe type as an Applicative</h2>

<p><code class="language-plaintext highlighter-rouge">Maybe</code> has the following implementation for Applicative typeclass (actual implementation in Haskell source is slightly different but does the exact same thing).</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">instance</span> <span class="kt">Applicative</span> <span class="kt">Maybe</span> <span class="kr">where</span>
    <span class="n">pure</span> <span class="n">x</span> <span class="o">=</span> <span class="kt">Just</span> <span class="n">x</span>

    <span class="kt">Just</span> <span class="n">f</span> <span class="o">&lt;*&gt;</span> <span class="kt">Just</span> <span class="n">x</span> <span class="o">=</span> <span class="kt">Just</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span>
    <span class="kr">_</span> <span class="o">&lt;*&gt;</span> <span class="kr">_</span>           <span class="o">=</span> <span class="kt">Nothing</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">pure</code> function just wraps the value in <code class="language-plaintext highlighter-rouge">Just</code>. For <code class="language-plaintext highlighter-rouge">&lt;*&gt;</code> it makes sense that we can perform function application only when both the function and the value are available inside the two <code class="language-plaintext highlighter-rouge">Maybe</code>s provided. If either isn’t available then the result is <code class="language-plaintext highlighter-rouge">Nothing</code>. Let’s confirm that this does what we expect.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-- ghci
λ&gt; Just (\x -&gt; x + 1) &lt;*&gt; Just 3
Just 4
λ&gt; Just (\x -&gt; x + 1) &lt;*&gt; Nothing
Nothing
λ&gt; Nothing &lt;*&gt; Just 3
Nothing
λ&gt; Nothing &lt;*&gt; Nothing
Nothing
</code></pre></div></div>

<p>Phew! after all this theory I can finally show you some example of when this is useful. Recall that functions in Haskell are <a href="Curried">https://fpunfold.com/2020/05/09/why-haskell-for-functional-programming/#currying</a> by default meaning that passing one argument to a multi-argument function returns another function that takes one less parameter. You can think of this as partially applying functions. So, when you do <code class="language-plaintext highlighter-rouge">(+) 2</code> it creates a new function that takes one integer and adds 2 to it. What do you think would happen if we do <code class="language-plaintext highlighter-rouge">Just (+) &lt;*&gt; Just 2</code>? Let’s analyze its type signature in ghci using <code class="language-plaintext highlighter-rouge">:t</code> command.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// ghci
λ&gt; :t Just (+) &lt;*&gt; Just 2
Just (+) &lt;*&gt; Just 2 :: Num a =&gt; Maybe (a -&gt; a)
</code></pre></div></div>

<p>We see that the signature of the function returned by <code class="language-plaintext highlighter-rouge">&lt;*&gt;</code> is <code class="language-plaintext highlighter-rouge">Num a =&gt; Maybe (a -&gt; a)</code>, which is a function wrapped inside a new <code class="language-plaintext highlighter-rouge">Maybe</code> Applicative Functor. Now we can pass it to <code class="language-plaintext highlighter-rouge">&lt;*&gt;</code> again with a fresh argument value!</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>λ&gt; Just (+) &lt;*&gt; Just 2 &lt;*&gt; Just 4
Just 6
</code></pre></div></div>

<p>We now have a result value wrapped in <code class="language-plaintext highlighter-rouge">Maybe</code> since our function <code class="language-plaintext highlighter-rouge">(+)</code> has been passed all the parameters it requires (2 and 4 in the example above). What does this mean? It means that we can take any arbitrary function, wrap it in a <code class="language-plaintext highlighter-rouge">Maybe</code> (called “lifting to Applicative”) and apply it successively to arguments wrapped in <code class="language-plaintext highlighter-rouge">Maybe</code>. If at any stage we see an argument that is <code class="language-plaintext highlighter-rouge">Nothing</code>, the result will automatically be <code class="language-plaintext highlighter-rouge">Nothing</code>. This simplifies and standardizes error handling!</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">λ</span><span class="o">&gt;</span> <span class="kt">Just</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="o">&lt;*&gt;</span> <span class="kt">Just</span> <span class="mi">2</span> <span class="o">&lt;*&gt;</span> <span class="kt">Just</span> <span class="mi">4</span>
<span class="kt">Just</span> <span class="mi">6</span>
<span class="err">λ</span><span class="o">&gt;</span> <span class="kt">Just</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="o">&lt;*&gt;</span> <span class="kt">Nothing</span> <span class="o">&lt;*&gt;</span> <span class="kt">Just</span> <span class="mi">4</span>
<span class="kt">Nothing</span>
<span class="err">λ</span><span class="o">&gt;</span> <span class="kt">Just</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="o">&lt;*&gt;</span> <span class="kt">Just</span> <span class="mi">2</span> <span class="o">&lt;*&gt;</span> <span class="kt">Nothing</span>
<span class="kt">Nothing</span>
</code></pre></div></div>

<p>Now let’s see a more relatable example. Suppose we want to parse parameters passed in a query string (a string containing key-value pairs). Say we want to parse the query string <code class="language-plaintext highlighter-rouge">firstName=fp&amp;lastName=unfold&amp;age=0&amp;email=contact@fpunfold.com</code> to a data type representing a Person. Our function should account for missing information in the encoded string and should fail gracefully in such cases. Let’s define our <code class="language-plaintext highlighter-rouge">Person</code> data type and write the type signature for our function.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- applicative.hs</span>
<span class="kr">data</span> <span class="kt">Person</span> <span class="o">=</span> <span class="kt">Pers</span> <span class="p">{</span>
        <span class="n">_firstName</span> <span class="o">::</span> <span class="kt">String</span> 
    <span class="p">,</span>   <span class="n">_lastName</span>  <span class="o">::</span> <span class="kt">String</span> 
    <span class="p">,</span>   <span class="n">_age</span>       <span class="o">::</span> <span class="kt">Int</span> 
    <span class="p">,</span>   <span class="n">_email</span>     <span class="o">::</span> <span class="kt">String</span>
    <span class="p">}</span> <span class="kr">deriving</span> <span class="kt">Show</span>

<span class="n">parseMaybe</span> <span class="o">::</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">Person</span>
</code></pre></div></div>

<p>Our data type <code class="language-plaintext highlighter-rouge">Person</code> contains four required fields that we want to parse from a query string. Function <code class="language-plaintext highlighter-rouge">parseMaybe</code> is our parsing function that tries to parse the passed query string and returns a <code class="language-plaintext highlighter-rouge">Just Person</code> if it was successful, and returns <code class="language-plaintext highlighter-rouge">Nothing</code> on any failure like insufficient information in the query string. To do that, we’ll first extract all (key, value) tuples from the query string using a <code class="language-plaintext highlighter-rouge">decode</code> function as shown below. We are using <code class="language-plaintext highlighter-rouge">splitOn</code> function from module Data.List.Split here. You can download the package using <code class="language-plaintext highlighter-rouge">cabal install split</code> command if you don’t have it available.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- applicative.hs</span>
<span class="kr">import</span> <span class="nn">Data.List.Split</span> <span class="p">(</span><span class="nf">splitOn</span><span class="p">)</span>

<span class="n">decode</span> <span class="o">::</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="p">[(</span><span class="kt">String</span><span class="p">,</span><span class="kt">String</span><span class="p">)]</span> 
<span class="n">decode</span> <span class="n">encoded</span> <span class="o">=</span> 
    <span class="n">fmap</span> <span class="n">toTup</span> <span class="o">.</span> <span class="n">filter</span> <span class="n">validTup</span> <span class="o">.</span> <span class="n">fmap</span> <span class="p">(</span><span class="n">splitOn</span> <span class="s">"="</span><span class="p">)</span> <span class="o">.</span> <span class="n">splitOn</span> <span class="s">"&amp;"</span> <span class="o">$</span> <span class="n">encoded</span>
    <span class="kr">where</span> 
        <span class="n">toTup</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
        <span class="n">validTup</span> <span class="n">xs</span> <span class="o">=</span> <span class="n">length</span> <span class="n">xs</span> <span class="o">==</span> <span class="mi">2</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">decode</code> function first splits the encoded string on “&amp;” character. Each part in the result is now expected to be a key-value pair separated by “=” character. So, we split each part on “=” character (mapping with <code class="language-plaintext highlighter-rouge">splitOn "="</code>) and filter out ones that do not contain exactly two elements after the split as those parts are invalid. Then, we just map all two-element lists (key-value pairs) to tuples. Let’s test the function in ghci.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// ghci
λ&gt; :l applicative.hs 
[1 of 1] Compiling Main             ( applicative.hs, interpreted )
Ok, one module loaded.
λ&gt; decode "firstName=fp&amp;lastName=unfold&amp;age=0&amp;email=contact@fpunfold.com"
[("firstName","fp"),("lastName","unfold"),("age","0"),("email","contact@fpunfold.com")]
λ&gt; decode "firstName=fp&amp;this=part=is=invalid"
[("firstName","fp")]
λ&gt; decode ""
[]
</code></pre></div></div>

<p>Now we create a <code class="language-plaintext highlighter-rouge">parsem :: [(String,String)] -&gt; Maybe Person</code> function that’ll try to create a <code class="language-plaintext highlighter-rouge">Person</code> from the key-value pairs. It uses Applicative Functor functions of <code class="language-plaintext highlighter-rouge">Maybe</code> to elegantly handle any errors.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- applicative.hs</span>
<span class="n">parsem</span> <span class="o">::</span> <span class="p">[(</span><span class="kt">String</span><span class="p">,</span><span class="kt">String</span><span class="p">)]</span> <span class="o">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">Person</span> 
<span class="n">parsem</span> <span class="n">kvs</span> <span class="o">=</span> <span class="n">pure</span> <span class="kt">Pers</span> 
    <span class="o">&lt;*&gt;</span> <span class="n">lookup</span> <span class="s">"firstName"</span> <span class="n">kvs</span>
    <span class="o">&lt;*&gt;</span> <span class="n">lookup</span> <span class="s">"lastName"</span> <span class="n">kvs</span>
    <span class="o">&lt;*&gt;</span> <span class="n">fmap</span> <span class="n">read</span> <span class="p">(</span><span class="n">lookup</span> <span class="s">"age"</span> <span class="n">kvs</span><span class="p">)</span>
    <span class="o">&lt;*&gt;</span> <span class="n">lookup</span> <span class="s">"email"</span> <span class="n">kvs</span>
</code></pre></div></div>

<p>And that’s all! Our <code class="language-plaintext highlighter-rouge">parsem</code> function looks for all the required fields in the passed key-value pairs using <code class="language-plaintext highlighter-rouge">lookup :: Eq k =&gt; k -&gt; [(k, v)] -&gt; Maybe v</code> function that returns the value corresponding to the passed key if found or <code class="language-plaintext highlighter-rouge">Nothing</code> otherwise. To handle any missing information automatically we make use of <code class="language-plaintext highlighter-rouge">&lt;*&gt;</code> function. First, we lift the <code class="language-plaintext highlighter-rouge">Pers</code> Data Constructor (which is just a function that creates a <code class="language-plaintext highlighter-rouge">Person</code>) using <code class="language-plaintext highlighter-rouge">pure</code> (which is <code class="language-plaintext highlighter-rouge">Just</code> for <code class="language-plaintext highlighter-rouge">Maybe</code> Applicative) and then we partially apply it on arguments wrapped in <code class="language-plaintext highlighter-rouge">Maybe</code> using <code class="language-plaintext highlighter-rouge">&lt;*&gt;</code>. If at any point an optional argument is <code class="language-plaintext highlighter-rouge">Nothing</code>, <code class="language-plaintext highlighter-rouge">&lt;*&gt;</code> returns <code class="language-plaintext highlighter-rouge">Nothing</code> and then the whole chain evaluates to <code class="language-plaintext highlighter-rouge">Nothing</code>. For age of the person we first lookup age in string format using <code class="language-plaintext highlighter-rouge">lookup</code> function and then convert it to an <code class="language-plaintext highlighter-rouge">Int</code> by mapping it with <code class="language-plaintext highlighter-rouge">read</code> function. Now, our final <code class="language-plaintext highlighter-rouge">parseMaybe :: String -&gt; Maybe Person</code> function is just a composition of <code class="language-plaintext highlighter-rouge">parsem</code> and <code class="language-plaintext highlighter-rouge">decode</code>.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- applicative.hs</span>
<span class="n">parseMaybe</span> <span class="o">::</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">Person</span> 
<span class="n">parseMaybe</span> <span class="o">=</span> <span class="n">parsem</span> <span class="o">.</span> <span class="n">decode</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// ghci
λ&gt; parseMaybe "firstName=fp&amp;lastName=unfold&amp;age=0&amp;email=contact@fpunfold.com"
Just (Pers {_firstName = "fp", _lastName = "unfold", _age = 0, _email = "contact@fpunfold.com"})
λ&gt; parseMaybe "firstName=fp&amp;lastName=unfold&amp;age=0" -- missing email
Nothing
λ&gt; parseMaybe "firstName=fp&amp;&amp;email=contact@fpunfold.com" -- missing lastName and age
Nothing
</code></pre></div></div>

<h2 id="either-as-an-applicative">Either as an Applicative</h2>

<p>Similar to <code class="language-plaintext highlighter-rouge">Maybe</code>, <code class="language-plaintext highlighter-rouge">Either l</code> is also an Applicative Functor as shown below.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">instance</span> <span class="kt">Applicative</span> <span class="p">(</span><span class="kt">Either</span> <span class="n">e</span><span class="p">)</span> <span class="kr">where</span>
    <span class="n">pure</span>          <span class="o">=</span> <span class="kt">Right</span>

    <span class="kt">Left</span>  <span class="n">e</span> <span class="o">&lt;*&gt;</span> <span class="kr">_</span> <span class="o">=</span> <span class="kt">Left</span> <span class="n">e</span>
    <span class="kt">Right</span> <span class="n">f</span> <span class="o">&lt;*&gt;</span> <span class="n">r</span> <span class="o">=</span> <span class="n">fmap</span> <span class="n">f</span> <span class="n">r</span>
</code></pre></div></div>

<p>Implementation is similar to <code class="language-plaintext highlighter-rouge">Maybe</code>. <code class="language-plaintext highlighter-rouge">&lt;*&gt;</code> performs function application only if both sides are <code class="language-plaintext highlighter-rouge">Right</code>. Otherwise it returns <code class="language-plaintext highlighter-rouge">Left</code> value from first or second parameter in that order.</p>

<p>Our <code class="language-plaintext highlighter-rouge">parsem</code> function works well but it doesn’t tell us much about failures. What if we want to know what field was missing? Is there another type that’s like <code class="language-plaintext highlighter-rouge">Maybe</code> but slightly more informative? It’s the <code class="language-plaintext highlighter-rouge">Either</code> type! We can use <code class="language-plaintext highlighter-rouge">Either String Person</code> instead of <code class="language-plaintext highlighter-rouge">Maybe Person</code> so that we can return some error in string format if something fails. And since <code class="language-plaintext highlighter-rouge">Either String</code> is an Applicative our code remains almost the same.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- applicative.hs</span>
<span class="n">eitherMaybe</span> <span class="o">::</span> <span class="n">l</span> <span class="o">-&gt;</span> <span class="kt">Maybe</span> <span class="n">r</span> <span class="o">-&gt;</span> <span class="kt">Either</span> <span class="n">l</span> <span class="n">r</span>
<span class="n">eitherMaybe</span> <span class="n">e</span> <span class="kt">Nothing</span>  <span class="o">=</span> <span class="kt">Left</span> <span class="n">e</span> 
<span class="n">eitherMaybe</span> <span class="kr">_</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Right</span> <span class="n">x</span>

<span class="n">parsee</span> <span class="o">::</span> <span class="p">[(</span><span class="kt">String</span><span class="p">,</span><span class="kt">String</span><span class="p">)]</span> <span class="o">-&gt;</span> <span class="kt">Either</span> <span class="kt">String</span> <span class="kt">Person</span> 
<span class="n">parsee</span> <span class="n">m</span> <span class="o">=</span> <span class="n">pure</span> <span class="kt">Pers</span>
    <span class="o">&lt;*&gt;</span> <span class="n">eitherMaybe</span> <span class="s">"firstName absent"</span> <span class="p">(</span><span class="n">lookup</span> <span class="s">"firstName"</span> <span class="n">m</span><span class="p">)</span>
    <span class="o">&lt;*&gt;</span> <span class="n">eitherMaybe</span> <span class="s">"lastName absent"</span> <span class="p">(</span><span class="n">lookup</span> <span class="s">"lastName"</span> <span class="n">m</span><span class="p">)</span>
    <span class="o">&lt;*&gt;</span> <span class="n">eitherMaybe</span> <span class="s">"age absent"</span> <span class="p">(</span><span class="n">fmap</span> <span class="n">read</span> <span class="o">.</span> <span class="n">lookup</span> <span class="s">"age"</span> <span class="o">$</span> <span class="n">m</span><span class="p">)</span>
    <span class="o">&lt;*&gt;</span> <span class="n">eitherMaybe</span> <span class="s">"email absent"</span> <span class="p">(</span><span class="n">lookup</span> <span class="s">"email"</span> <span class="n">m</span><span class="p">)</span>
</code></pre></div></div>

<p>Since <code class="language-plaintext highlighter-rouge">lookup</code> function returns a <code class="language-plaintext highlighter-rouge">Maybe</code> we first need an easy way to convert it to an <code class="language-plaintext highlighter-rouge">Either</code>. We define a simple <code class="language-plaintext highlighter-rouge">eitherMaybe</code> function to handle this. It takes an error value and a <code class="language-plaintext highlighter-rouge">Maybe</code>. For <code class="language-plaintext highlighter-rouge">Just x</code> it wraps the value in a <code class="language-plaintext highlighter-rouge">Right</code> and for <code class="language-plaintext highlighter-rouge">Nothing</code> it returns the passed error value wrapped in a <code class="language-plaintext highlighter-rouge">Left</code>. Next is our new parsing function <code class="language-plaintext highlighter-rouge">parsee</code>. It remains almost identical in structure to our <code class="language-plaintext highlighter-rouge">parsem</code> function. The only difference is that we convert the <code class="language-plaintext highlighter-rouge">Maybe</code> results of <code class="language-plaintext highlighter-rouge">lookup</code> function into <code class="language-plaintext highlighter-rouge">Either</code> and provide an informative error message if the lookup failed. The usage of Applicative’s <code class="language-plaintext highlighter-rouge">&lt;*&gt;</code> function remains the same. Instead of working on <code class="language-plaintext highlighter-rouge">Maybe</code>s it works on <code class="language-plaintext highlighter-rouge">Either</code>s this time.</p>

<p>Let’s also define a <code class="language-plaintext highlighter-rouge">parseEither :: String -&gt; Either String Person</code> function like we defined <code class="language-plaintext highlighter-rouge">parseMaybe</code> before.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- applicative.hs</span>
<span class="n">parseEither</span> <span class="o">::</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="kt">Either</span> <span class="kt">String</span> <span class="kt">Person</span> 
<span class="n">parseEither</span> <span class="o">=</span> <span class="n">parsee</span> <span class="o">.</span> <span class="n">decode</span>
</code></pre></div></div>

<p>Let’s give it a go in ghci.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// ghci
λ&gt; :l applicative.hs 
[1 of 1] Compiling Main             ( applicative.hs, interpreted )
Ok, one module loaded.
λ&gt; parseEither "firstName=fp&amp;lastName=unfold&amp;age=0&amp;email=contact@fpunfold.com"
Right (Pers {_firstName = "fp", _lastName = "unfold", _age = 0, _email = "contact@fpunfold.com"})
λ&gt; parseEither "firstName=fp&amp;lastName=unfold&amp;age=0" -- missing email
Left "email absent"
λ&gt; parseEither "firstName=fp&amp;&amp;email=contact@fpunfold.com" -- missing lastName and age
Left "lastName absent"
</code></pre></div></div>

<p>Isn’t this great?</p>

<h2 id="summary">Summary</h2>
<p>We saw what Applicative Functors are and how they can be useful in providing elegant solutions to some every day problems. In fact, Haskell language has some powerful and brilliant parsing tools based on something called Parser Combinators which in turn are based on Applicative functors! I will cover Parser Combinator in separate posts. We also haven’t seen how other Applicatives such as Lists behave and what are some more interesting properties of Applicatives. All that will be future articles as well! I hope you learned a thing or two from this post and that your time here was well spent. :)</p>

  </div><a class="u-url" href="/haskell/functional-programming/2020/05/12/applicative-functor-for-beginners.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">fpunfold</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">fpunfold</li><li><a class="u-email" href="mailto:amoghdroid09@gmail.com">amoghdroid09@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/amogh09"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">amogh09</span></a></li><li><a href="https://www.twitter.com/RathoreAmogh"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">RathoreAmogh</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>My adventures with code.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
