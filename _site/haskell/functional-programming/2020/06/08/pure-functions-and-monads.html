<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Pure functions and Monads | fpunfold</title>
<meta name="generator" content="Jekyll v3.9.0" />
<meta property="og:title" content="Pure functions and Monads" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="In today’s article I’ll be showing you a way to write pure functions that are Monad-friendly meaning that they are composable with Monadic contexts." />
<meta property="og:description" content="In today’s article I’ll be showing you a way to write pure functions that are Monad-friendly meaning that they are composable with Monadic contexts." />
<link rel="canonical" href="http://localhost:4000/haskell/functional-programming/2020/06/08/pure-functions-and-monads.html" />
<meta property="og:url" content="http://localhost:4000/haskell/functional-programming/2020/06/08/pure-functions-and-monads.html" />
<meta property="og:site_name" content="fpunfold" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-06-08T19:30:17-04:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Pure functions and Monads" />
<script type="application/ld+json">
{"url":"http://localhost:4000/haskell/functional-programming/2020/06/08/pure-functions-and-monads.html","headline":"Pure functions and Monads","dateModified":"2020-06-08T19:30:17-04:00","datePublished":"2020-06-08T19:30:17-04:00","description":"In today’s article I’ll be showing you a way to write pure functions that are Monad-friendly meaning that they are composable with Monadic contexts.","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/haskell/functional-programming/2020/06/08/pure-functions-and-monads.html"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="fpunfold" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">fpunfold</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Pure functions and Monads</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2020-06-08T19:30:17-04:00" itemprop="datePublished">Jun 8, 2020
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>In today’s article I’ll be showing you a way to write pure functions that are Monad-friendly meaning that they are composable with Monadic contexts.</p>

<h2 id="imports-and-extensions">Imports and Extensions</h2>
<p>Let’s first get the imports and language extensions we’d be using for this article out of the way.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- app.hs</span>
<span class="cp">{-# LANGUAGE FlexibleContexts           #-}</span>
<span class="cp">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span>

<span class="kr">import</span>           <span class="nn">Control.Monad</span>          <span class="p">(</span><span class="nf">forever</span><span class="p">)</span>
<span class="kr">import</span>           <span class="nn">Control.Monad.Except</span>   <span class="p">(</span><span class="kt">ExceptT</span><span class="p">,</span> <span class="kt">MonadError</span><span class="p">,</span> <span class="nf">catchError</span><span class="p">,</span>
                                         <span class="nf">runExceptT</span><span class="p">,</span> <span class="nf">throwError</span><span class="p">)</span>
<span class="kr">import</span>           <span class="nn">Control.Monad.IO.Class</span> <span class="p">(</span><span class="kt">MonadIO</span><span class="p">,</span> <span class="nf">liftIO</span><span class="p">)</span>
<span class="kr">import</span>           <span class="nn">Control.Monad.State</span>    <span class="p">(</span><span class="kt">MonadState</span><span class="p">,</span> <span class="kt">StateT</span><span class="p">,</span> <span class="nf">evalStateT</span><span class="p">,</span> <span class="nf">get</span><span class="p">,</span>
                                         <span class="nf">modify</span><span class="p">)</span>
<span class="kr">import</span>           <span class="nn">Numeric</span>                <span class="p">(</span><span class="nf">readDec</span><span class="p">)</span>
<span class="kr">import</span>           <span class="nn">System.IO</span>              <span class="p">(</span><span class="kt">BufferMode</span> <span class="p">(</span><span class="kt">NoBuffering</span><span class="p">),</span>
                                         <span class="nf">hSetBuffering</span><span class="p">,</span> <span class="nf">stdout</span><span class="p">)</span>
</code></pre></div></div>

<p>Cool. We can get started now!</p>

<h2 id="pure-functions-and-monads">Pure functions and Monads</h2>
<p>Say you want to write a pure function that has a possibility of failing. What type signature would you give it? One of the common ones is <code class="language-plaintext highlighter-rouge">Either String a</code>. For example, let’s write a function that given a list of integers returns their average.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- app.hs</span>
<span class="n">avg'</span> <span class="o">::</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="kt">Either</span> <span class="kt">String</span> <span class="kt">Double</span>
<span class="n">avg'</span> <span class="kt">[]</span> <span class="o">=</span> <span class="kt">Left</span> <span class="s">"Cannot take average of empty list"</span>
<span class="n">avg'</span> <span class="n">xs</span> <span class="o">=</span> <span class="kt">Right</span> <span class="o">$</span> <span class="n">fromIntegral</span> <span class="p">(</span><span class="n">sum</span> <span class="n">xs</span><span class="p">)</span> <span class="o">/</span> <span class="n">fromIntegral</span> <span class="p">(</span><span class="n">length</span> <span class="n">xs</span><span class="p">)</span>
</code></pre></div></div>

<p>Functions with concrete return types such as <code class="language-plaintext highlighter-rouge">Either String a</code> are not directly compatible with Monadic contexts other than <code class="language-plaintext highlighter-rouge">Either String</code>. Suppose we have an <code class="language-plaintext highlighter-rouge">App</code> monad for our application defined as follows.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- app.hs</span>
<span class="kr">newtype</span> <span class="kt">App</span> <span class="n">s</span> <span class="n">m</span> <span class="n">e</span> <span class="n">a</span> <span class="o">=</span> <span class="kt">App</span>
  <span class="p">{</span> <span class="n">unapp</span> <span class="o">::</span> <span class="kt">StateT</span> <span class="n">s</span> <span class="p">(</span><span class="kt">ExceptT</span> <span class="n">e</span> <span class="n">m</span><span class="p">)</span> <span class="n">a</span>
  <span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Functor</span><span class="p">,</span> <span class="kt">Applicative</span><span class="p">,</span> <span class="kt">Monad</span><span class="p">,</span> <span class="kt">MonadError</span> <span class="n">e</span><span class="p">,</span> <span class="kt">MonadIO</span><span class="p">,</span> <span class="kt">MonadState</span> <span class="n">s</span><span class="p">)</span>
</code></pre></div></div>

<p>Calling our <code class="language-plaintext highlighter-rouge">avg'</code> function from within <code class="language-plaintext highlighter-rouge">App</code> context is not straightforward as the <code class="language-plaintext highlighter-rouge">Either e</code> monad is not compatible with our <code class="language-plaintext highlighter-rouge">App</code> monad out of the box. We’ll need to write a function that can lift a value of type <code class="language-plaintext highlighter-rouge">Either e a</code> to <code class="language-plaintext highlighter-rouge">App s m e a</code> type. Although writing such a function is possible, we can do better.</p>

<p>Instead of coding pure functions to concrete types, we can code them to typeclasses. The typeclass that abstracts the functionality offered by <code class="language-plaintext highlighter-rouge">Either e</code> type is <code class="language-plaintext highlighter-rouge">MonadError e</code>. Let’s redefine our average function so that it operates within <code class="language-plaintext highlighter-rouge">MonadError</code> context.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- app.hs</span>
<span class="n">avg</span> <span class="o">::</span> <span class="kt">MonadError</span> <span class="kt">String</span> <span class="n">m</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="kt">Double</span>
<span class="n">avg</span> <span class="kt">[]</span> <span class="o">=</span> <span class="n">throwError</span> <span class="s">"Cannot take average of empty list"</span>
<span class="n">avg</span> <span class="n">xs</span> <span class="o">=</span> <span class="n">pure</span> <span class="o">$</span> <span class="n">fromIntegral</span> <span class="p">(</span><span class="n">sum</span> <span class="n">xs</span><span class="p">)</span> <span class="o">/</span> <span class="n">fromIntegral</span> <span class="p">(</span><span class="n">length</span> <span class="n">xs</span><span class="p">)</span>
</code></pre></div></div>

<p>What did we change? Notice that we no longer return <code class="language-plaintext highlighter-rouge">Either String Double</code> anymore. Instead, we return a <code class="language-plaintext highlighter-rouge">Double</code> within a <code class="language-plaintext highlighter-rouge">MonadError String</code> context. This <code class="language-plaintext highlighter-rouge">MonadError String</code> context could be any <code class="language-plaintext highlighter-rouge">MonadError String</code> instance! Notice that our <code class="language-plaintext highlighter-rouge">App s m e</code> monad is an instance of <code class="language-plaintext highlighter-rouge">MonadError e</code> making it compatible with our new <code class="language-plaintext highlighter-rouge">avg</code> function when <code class="language-plaintext highlighter-rouge">e = String</code></p>

<p>We have also replaced <code class="language-plaintext highlighter-rouge">Left</code> with <code class="language-plaintext highlighter-rouge">throwError</code> and <code class="language-plaintext highlighter-rouge">Right</code> with <code class="language-plaintext highlighter-rouge">pure</code>. For <code class="language-plaintext highlighter-rouge">Either e a</code> monad the functionality is exactly the same as before but now our function is more generic.</p>

<p>Let’s confirm that <code class="language-plaintext highlighter-rouge">avg</code> function does indeed work within different <code class="language-plaintext highlighter-rouge">MonadError String</code> contexts.</p>

<pre><code class="language-&quot;haskell">-- ghci
λ&gt; avg [1,2,3] :: Either String Double
Right 2.0
λ&gt; let x = avg [1,2,3] :: Monad m =&gt; App s m String Double
λ&gt; :t x
x :: Monad m =&gt; App s m String Double
</code></pre>

<p>Nice.</p>

<h2 id="applying-the-knowledge">Applying the knowledge</h2>
<p>Let’s now write a simple application that would demonstrate the usefulness of Monad compatible pure functions. We will write a console app to print online averages of integers. The app will continuously keep asking the user for integer values and print the average of all values collected until now after each integer is read.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Enter an integer: 5
Current avg: 5.0
Enter an integer: 0
Current avg: 2.5
Enter an integer: abc
Could not parse "abc" to an int
Enter an integer: -2
Current avg: 1.0
</code></pre></div></div>

<p>We will use <code class="language-plaintext highlighter-rouge">State [Int]</code> monad to store the current state of integers collected. So, our app will run in <code class="language-plaintext highlighter-rouge">App [Int] IO String</code> monadic context. Let’s declare a type alias for this type for convenience.</p>

<pre><code class="language-&quot;haskell">type MyApp = App [Int] IO String
</code></pre>

<p>To run our <code class="language-plaintext highlighter-rouge">App s m e</code> monad, we will need to unwrap and run all its transformers one by one.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- app.hs</span>
<span class="n">runapp</span> <span class="o">::</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="o">=&gt;</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="kt">App</span> <span class="n">s</span> <span class="n">m</span> <span class="n">e</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="p">(</span><span class="kt">Either</span> <span class="n">e</span> <span class="n">a</span><span class="p">)</span>
<span class="n">runapp</span> <span class="n">s</span> <span class="o">=</span> <span class="n">runExceptT</span> <span class="o">.</span> <span class="n">flip</span> <span class="n">evalStateT</span> <span class="n">s</span> <span class="o">.</span> <span class="n">unapp</span>
</code></pre></div></div>

<p>Now let’s define a <code class="language-plaintext highlighter-rouge">readInt</code> function that will try to parse an integer from a string while handling any errors. For this we will use <code class="language-plaintext highlighter-rouge">readDec</code> function from <code class="language-plaintext highlighter-rouge">Numeric</code> module with some modifications.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- app.hs</span>
<span class="n">readInt</span> <span class="o">::</span> <span class="kt">MonadError</span> <span class="kt">String</span> <span class="n">m</span> <span class="o">=&gt;</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="kt">Int</span>
<span class="n">readInt</span> <span class="kt">[]</span>       <span class="o">=</span> <span class="n">throwError</span> <span class="s">"Cannot read int from empty string"</span>
<span class="n">readInt</span> <span class="p">(</span><span class="sc">'-'</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="o">=</span> <span class="n">negate</span> <span class="o">&lt;$&gt;</span> <span class="n">readInt</span> <span class="n">xs</span> <span class="c1">-- Handle negative integers</span>
<span class="n">readInt</span> <span class="n">xs</span>       <span class="o">=</span> <span class="kr">case</span> <span class="n">readDec</span> <span class="n">xs</span> <span class="kr">of</span>
  <span class="p">[(</span><span class="n">v</span><span class="p">,</span> <span class="s">""</span><span class="p">)]</span> <span class="o">-&gt;</span> <span class="n">pure</span> <span class="n">v</span>
  <span class="kr">_</span>         <span class="o">-&gt;</span> <span class="n">throwError</span> <span class="o">$</span> <span class="s">"Could not parse "</span> <span class="o">&lt;&gt;</span> <span class="n">show</span> <span class="n">xs</span> <span class="o">&lt;&gt;</span> <span class="s">" to an int"</span>
</code></pre></div></div>

<p>Note that we have defined <code class="language-plaintext highlighter-rouge">readInt</code> function within <code class="language-plaintext highlighter-rouge">MonadError String</code> context just like the <code class="language-plaintext highlighter-rouge">avg</code> function.</p>

<p>Next, we define a function <code class="language-plaintext highlighter-rouge">getInt</code> that will ask the user to input an integer, try to parse the input, and ask the user to input again if there was any error.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- app.hs</span>
<span class="n">getInt'</span> <span class="o">::</span> <span class="kt">MyApp</span> <span class="kt">Int</span>
<span class="n">getInt'</span> <span class="o">=</span>
      <span class="n">liftIO</span> <span class="p">(</span><span class="n">putStr</span> <span class="s">"Enter an integer: "</span><span class="p">)</span>
  <span class="o">*&gt;</span>  <span class="n">liftIO</span> <span class="n">getLine</span>
  <span class="o">&gt;&gt;=</span> <span class="n">readInt</span>

<span class="n">getInt</span> <span class="o">::</span> <span class="kt">MyApp</span> <span class="kt">Int</span>
<span class="n">getInt</span> <span class="o">=</span> <span class="n">getInt'</span> <span class="p">`</span><span class="n">catchError</span><span class="p">`</span> <span class="nf">\</span><span class="n">e</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">liftIO</span> <span class="o">.</span> <span class="n">putStrLn</span> <span class="o">$</span> <span class="n">e</span><span class="p">)</span> <span class="o">*&gt;</span> <span class="n">getInt</span>
</code></pre></div></div>

<p>Note how we are able to call our pure <code class="language-plaintext highlighter-rouge">readInt</code> function from within <code class="language-plaintext highlighter-rouge">MyApp</code> monad without any lifting.</p>

<p>Alright, we have all the pieces we need. Now let’s define a loop that would ask the user for input and display the current averages.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- app.hs</span>
<span class="n">go</span> <span class="o">::</span> <span class="kt">MyApp</span> <span class="nb">()</span>
<span class="n">go</span> <span class="o">=</span> <span class="n">forever</span> <span class="o">$</span> <span class="kr">do</span>
  <span class="n">x</span> <span class="o">&lt;-</span> <span class="n">getInt</span>       <span class="c1">-- get int from user</span>
  <span class="n">modify</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="p">)</span>       <span class="c1">-- prepend new int to our state</span>
  <span class="n">y</span> <span class="o">&lt;-</span> <span class="n">avg</span> <span class="o">=&lt;&lt;</span> <span class="n">get</span>  <span class="c1">-- compute the average of collected ints</span>
  <span class="n">liftIO</span> <span class="o">$</span> <span class="n">putStrLn</span> <span class="o">$</span> <span class="s">"Current avg: "</span> <span class="o">&lt;&gt;</span> <span class="n">show</span> <span class="n">y</span>
</code></pre></div></div>

<p>Once again, we are able to call pure <code class="language-plaintext highlighter-rouge">avg</code> function from <code class="language-plaintext highlighter-rouge">MyApp</code> context without having to perform any lift juggling.</p>

<p>And that’s it. We can now call <code class="language-plaintext highlighter-rouge">go</code> from our <code class="language-plaintext highlighter-rouge">main</code> function to start the app.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- app.hs </span>
<span class="n">main</span> <span class="o">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="n">main</span> <span class="o">=</span> <span class="kr">do</span>
  <span class="n">hSetBuffering</span> <span class="n">stdout</span> <span class="kt">NoBuffering</span> <span class="c1">-- so that everything is printed right away</span>
  <span class="n">runapp</span> <span class="kt">[]</span> <span class="n">go</span> <span class="o">&gt;&gt;=</span> <span class="n">either</span> <span class="n">print</span> <span class="p">(</span><span class="n">const</span> <span class="o">$</span> <span class="n">pure</span> <span class="nb">()</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="conclusion-and-follow-ups">Conclusion and follow-ups</h2>
<p>We saw today how pure functions can be made more generic so that they may be called from monadic contexts without much trouble.</p>

<p>You might have noticed that <code class="language-plaintext highlighter-rouge">MonadError String</code> is not completely generic as it assumes the error type to be <code class="language-plaintext highlighter-rouge">String</code>. We cannot get rid of the concrete error type as we need it to create the error value.</p>

<p>However, we can make our app monad an instance of <code class="language-plaintext highlighter-rouge">Bifunctor</code> to easily convert a value of type <code class="language-plaintext highlighter-rouge">App s m e a</code> to <code class="language-plaintext highlighter-rouge">App s m e' a</code>. The function that does this is called <a href="https://hackage.haskell.org/package/base-4.14.0.0/docs/Data-Bifunctor.html#v:first">first</a>. I will cover <a href="https://hackage.haskell.org/package/base-4.14.0.0/docs/Data-Bifunctor.html">Bifunctor</a> in detail in a separate blog post.</p>

<h2 id="appendix">Appendix</h2>
<p>Complete program is reproduced below if you want to copy it. ;)</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- app.hs</span>
<span class="cp">{-# LANGUAGE FlexibleContexts           #-}</span>
<span class="cp">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span>

<span class="kr">import</span>           <span class="nn">Control.Monad</span>          <span class="p">(</span><span class="nf">forever</span><span class="p">)</span>
<span class="kr">import</span>           <span class="nn">Control.Monad.Except</span>   <span class="p">(</span><span class="kt">ExceptT</span><span class="p">,</span> <span class="kt">MonadError</span><span class="p">,</span> <span class="nf">catchError</span><span class="p">,</span>
                                         <span class="nf">runExceptT</span><span class="p">,</span> <span class="nf">throwError</span><span class="p">)</span>
<span class="kr">import</span>           <span class="nn">Control.Monad.IO.Class</span> <span class="p">(</span><span class="kt">MonadIO</span><span class="p">,</span> <span class="nf">liftIO</span><span class="p">)</span>
<span class="kr">import</span>           <span class="nn">Control.Monad.State</span>    <span class="p">(</span><span class="kt">MonadState</span><span class="p">,</span> <span class="kt">StateT</span><span class="p">,</span> <span class="nf">evalStateT</span><span class="p">,</span> <span class="nf">get</span><span class="p">,</span>
                                         <span class="nf">modify</span><span class="p">)</span>
<span class="kr">import</span>           <span class="nn">Numeric</span>                <span class="p">(</span><span class="nf">readDec</span><span class="p">)</span>
<span class="kr">import</span>           <span class="nn">System.IO</span>              <span class="p">(</span><span class="kt">BufferMode</span> <span class="p">(</span><span class="kt">NoBuffering</span><span class="p">),</span>
                                         <span class="nf">hSetBuffering</span><span class="p">,</span> <span class="nf">stdout</span><span class="p">)</span>

<span class="n">avg</span> <span class="o">::</span> <span class="p">(</span><span class="kt">MonadError</span> <span class="kt">String</span> <span class="n">m</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="kt">Double</span>
<span class="n">avg</span> <span class="kt">[]</span> <span class="o">=</span> <span class="n">throwError</span> <span class="s">"Cannot take average of empty list"</span>
<span class="n">avg</span> <span class="n">xs</span> <span class="o">=</span> <span class="n">pure</span> <span class="o">$</span> <span class="n">fromIntegral</span> <span class="p">(</span><span class="n">sum</span> <span class="n">xs</span><span class="p">)</span> <span class="o">/</span> <span class="n">fromIntegral</span> <span class="p">(</span><span class="n">length</span> <span class="n">xs</span><span class="p">)</span>

<span class="n">readInt</span> <span class="o">::</span> <span class="kt">MonadError</span> <span class="kt">String</span> <span class="n">m</span> <span class="o">=&gt;</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="kt">Int</span>
<span class="n">readInt</span> <span class="kt">[]</span>       <span class="o">=</span> <span class="n">throwError</span> <span class="s">"Cannot read int from empty string"</span>
<span class="n">readInt</span> <span class="p">(</span><span class="sc">'-'</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="o">=</span> <span class="n">negate</span> <span class="o">&lt;$&gt;</span> <span class="n">readInt</span> <span class="n">xs</span> <span class="c1">-- Handle negative integers</span>
<span class="n">readInt</span> <span class="n">xs</span>       <span class="o">=</span> <span class="kr">case</span> <span class="n">readDec</span> <span class="n">xs</span> <span class="kr">of</span>
  <span class="p">[(</span><span class="n">v</span><span class="p">,</span> <span class="s">""</span><span class="p">)]</span> <span class="o">-&gt;</span> <span class="n">pure</span> <span class="n">v</span>
  <span class="kr">_</span>         <span class="o">-&gt;</span> <span class="n">throwError</span> <span class="o">$</span> <span class="s">"Could not parse "</span> <span class="o">&lt;&gt;</span> <span class="n">show</span> <span class="n">xs</span> <span class="o">&lt;&gt;</span> <span class="s">" to an int"</span>

<span class="kr">newtype</span> <span class="kt">App</span> <span class="n">s</span> <span class="n">m</span> <span class="n">e</span> <span class="n">a</span> <span class="o">=</span> <span class="kt">App</span>
  <span class="p">{</span> <span class="n">unapp</span> <span class="o">::</span> <span class="kt">StateT</span> <span class="n">s</span> <span class="p">(</span><span class="kt">ExceptT</span> <span class="n">e</span> <span class="n">m</span><span class="p">)</span> <span class="n">a</span>
  <span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Functor</span><span class="p">,</span> <span class="kt">Applicative</span><span class="p">,</span> <span class="kt">Monad</span><span class="p">,</span> <span class="kt">MonadError</span> <span class="n">e</span><span class="p">,</span> <span class="kt">MonadIO</span><span class="p">,</span> <span class="kt">MonadState</span> <span class="n">s</span><span class="p">)</span>

<span class="kr">type</span> <span class="kt">MyApp</span> <span class="o">=</span> <span class="kt">App</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="kt">IO</span> <span class="kt">String</span>

<span class="n">runapp</span> <span class="o">::</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="o">=&gt;</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="kt">App</span> <span class="n">s</span> <span class="n">m</span> <span class="n">e</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="p">(</span><span class="kt">Either</span> <span class="n">e</span> <span class="n">a</span><span class="p">)</span>
<span class="n">runapp</span> <span class="n">s</span> <span class="o">=</span> <span class="n">runExceptT</span> <span class="o">.</span> <span class="n">flip</span> <span class="n">evalStateT</span> <span class="n">s</span> <span class="o">.</span> <span class="n">unapp</span>

<span class="n">getInt'</span> <span class="o">::</span> <span class="kt">MyApp</span> <span class="kt">Int</span>
<span class="n">getInt'</span> <span class="o">=</span>
      <span class="n">liftIO</span> <span class="p">(</span><span class="n">putStr</span> <span class="s">"Enter an integer: "</span><span class="p">)</span>
  <span class="o">*&gt;</span>  <span class="n">liftIO</span> <span class="n">getLine</span>
  <span class="o">&gt;&gt;=</span> <span class="n">readInt</span>

<span class="n">getInt</span> <span class="o">::</span> <span class="kt">MyApp</span> <span class="kt">Int</span>
<span class="n">getInt</span> <span class="o">=</span> <span class="n">getInt'</span> <span class="p">`</span><span class="n">catchError</span><span class="p">`</span> <span class="nf">\</span><span class="n">e</span> <span class="o">-&gt;</span> <span class="n">printError</span> <span class="n">e</span> <span class="o">*&gt;</span> <span class="n">getInt</span>
  <span class="kr">where</span> <span class="n">printError</span> <span class="n">e</span> <span class="o">=</span> <span class="n">liftIO</span> <span class="o">$</span> <span class="n">putStrLn</span> <span class="n">e</span>

<span class="n">go</span> <span class="o">::</span> <span class="kt">MyApp</span> <span class="nb">()</span>
<span class="n">go</span> <span class="o">=</span> <span class="n">forever</span> <span class="o">$</span> <span class="kr">do</span>
  <span class="n">x</span> <span class="o">&lt;-</span> <span class="n">getInt</span>
  <span class="n">modify</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="p">)</span>
  <span class="n">y</span> <span class="o">&lt;-</span> <span class="n">avg</span> <span class="o">=&lt;&lt;</span> <span class="n">get</span>
  <span class="n">liftIO</span> <span class="o">$</span> <span class="n">putStrLn</span> <span class="o">$</span> <span class="s">"Current avg: "</span> <span class="o">&lt;&gt;</span> <span class="n">show</span> <span class="n">y</span>

<span class="n">main</span> <span class="o">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="n">main</span> <span class="o">=</span> <span class="kr">do</span>
  <span class="n">hSetBuffering</span> <span class="n">stdout</span> <span class="kt">NoBuffering</span>
  <span class="n">runapp</span> <span class="kt">[]</span> <span class="n">go</span> <span class="o">&gt;&gt;=</span> <span class="n">either</span> <span class="n">print</span> <span class="p">(</span><span class="n">const</span> <span class="o">$</span> <span class="n">pure</span> <span class="nb">()</span><span class="p">)</span>
</code></pre></div></div>

  </div><a class="u-url" href="/haskell/functional-programming/2020/06/08/pure-functions-and-monads.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">fpunfold</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">fpunfold</li><li><a class="u-email" href="mailto:amoghdroid09@gmail.com">amoghdroid09@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/amogh09"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">amogh09</span></a></li><li><a href="https://www.twitter.com/RathoreAmogh"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">RathoreAmogh</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>My adventures with code.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
